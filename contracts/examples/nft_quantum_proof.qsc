// contracts/examples/nft_quantum_proof.qsc
// Quantum NFT Smart Contract for Nyxora

// This contract mints NFTs with embedded quantum proof hashes,
// creating truly unique digital assets with quantum-enhanced provenance.

contract QuantumNFT {
    address owner;
    mapping(uint256 => string) public tokenURI;
    mapping(uint256 => bytes32) public quantumProofHash;
    mapping(uint256 => address) public tokenOwner;
    mapping(address => uint256[]) public ownedTokens;
    
    uint256 public tokenCount;
    
    event QuantumNFTMinted(
        uint256 indexed tokenId, 
        address indexed owner, 
        bytes32 indexed quantumProofHash,
        string tokenUri
    );
    
    constructor() {
        owner = msg.sender;
        tokenCount = 0;
    }
    
    function mintNFT(
        string memory _tokenURI,
        bytes32 _quantumProofHash
    ) public returns (uint256 tokenId) {
        tokenId = tokenCount++;
        
        tokenURI[tokenId] = _tokenURI;
        quantumProofHash[tokenId] = _quantumProofHash;
        tokenOwner[tokenId] = msg.sender;
        ownedTokens[msg.sender].push(tokenId);
        
        // Verify the quantum proof hash is valid
        require(isValidQuantumProofHash(_quantumProofHash), "Invalid quantum proof hash");
        
        emit QuantumNFTMinted(tokenId, msg.sender, _quantumProofHash, _tokenURI);
    }
    
    function isValidQuantumProofHash(bytes32 proofHash) internal pure returns (bool) {
        // In a real implementation, this would verify that the proof hash
        // corresponds to a valid quantum proof generated by the hexagonal circuits
        // For now, we'll just check that it's not zero
        return proofHash != bytes32(0);
    }
    
    function getOwnedTokens(address _owner) public view returns (uint256[] memory) {
        return ownedTokens[_owner];
    }
    
    function transferFrom(
        uint256 tokenId,
        address from,
        address to
    ) public {
        require(tokenOwner[tokenId] == from, "Not the token owner");
        require(msg.sender == from || isApprovedOrOwner(msg.sender, tokenId), "Not approved or owner");
        
        // Transfer the token
        tokenOwner[tokenId] = to;
        
        // Update the owned tokens arrays
        removeTokenFromOwner(from, tokenId);
        ownedTokens[to].push(tokenId);
    }
    
    function removeTokenFromOwner(address owner, uint256 tokenId) internal {
        uint256[] storage tokens = ownedTokens[owner];
        uint256 targetIndex;
        bool found = false;
        
        for (uint256 i = 0; i < tokens.length; i++) {
            if (tokens[i] == tokenId) {
                targetIndex = i;
                found = true;
                break;
            }
        }
        
        if (found) {
            // Replace the found token with the last token and pop
            tokens[targetIndex] = tokens[tokens.length - 1];
            tokens.pop();
        }
    }
    
    function isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        // Simplified implementation - in reality would check both ownership and approval
        return tokenOwner[tokenId] == spender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }
}