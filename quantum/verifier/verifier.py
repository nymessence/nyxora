# quantum/verifier/verifier.py
"""
Quantum Proof Verifier for Nyxora's Proof-of-Quantum (PoQ) System

This module verifies quantum proofs generated by the hexagonal quantum circuits.
The verifier ensures that the proof was generated from a valid quantum computation
without requiring the verifier to perform the quantum computation itself.
"""

import hashlib
import json
import sys
import os

# Add the circuits directory to the path so we can import the hex_hadamard_cnot module
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'circuits'))

from hex_hadamard_cnot import HexagonalQuantumCircuit, generate_quantum_proof


class QuantumProofVerifier:
    """
    Verifies quantum proofs generated by the hexagonal quantum circuits.
    """

    def __init__(self):
        self.valid_proofs = set()  # Keep track of verified proofs to prevent replay attacks

    def verify_proof(self, proof):
        """
        Verify a quantum proof.

        Args:
            proof: A dictionary containing the quantum proof components

        Returns:
            True if the proof is valid, False otherwise
        """
        # Check if proof has required fields
        required_fields = [
            'circuit_descriptor',
            'measurement_results',
            'proof_artifact',
            'qubit_count',
            'timestamp'
        ]

        for field in required_fields:
            if field not in proof:
                print(f"Missing required field: {field}")
                return False

        # Check if this proof has already been verified (replay attack prevention)
        proof_hash = hashlib.sha256(str(proof).encode()).hexdigest()
        if proof_hash in self.valid_proofs:
            print("Proof already verified (replay attack prevention)")
            return False

        # Verify the proof artifact matches the circuit descriptor and measurement results
        if not self._verify_proof_artifact(proof):
            print("Proof artifact verification failed")
            return False

        # Verify the circuit descriptor is valid
        if not self._verify_circuit_descriptor(proof['circuit_descriptor']):
            print("Circuit descriptor verification failed")
            return False

        # Verify the measurement results are consistent with the expected format
        if not self._verify_measurement_results(proof['measurement_results'], proof['qubit_count']):
            print("Measurement results verification failed")
            return False

        # If all checks pass, add the proof to the valid set and return True
        self.valid_proofs.add(proof_hash)
        return True

    def _verify_proof_artifact(self, proof):
        """
        Verify that the proof artifact matches the circuit descriptor and measurement results.
        """
        # Reconstruct the proof artifact from the provided data
        expected_input = proof['circuit_descriptor'] + ''.join(map(str, proof['measurement_results']))
        expected_artifact = hashlib.sha256(expected_input.encode()).hexdigest()

        # Compare with the provided proof artifact
        return expected_artifact == proof['proof_artifact']

    def _verify_circuit_descriptor(self, descriptor_str):
        """
        Verify that the circuit descriptor is properly formatted and valid.
        """
        try:
            descriptor = json.loads(descriptor_str)

            # Check for required fields in the descriptor
            required_descriptor_fields = [
                'qubit_count',
                'layers',
                'circuit_width',
                'circuit_depth'
            ]

            for field in required_descriptor_fields:
                if field not in descriptor:
                    return False

            # Additional validation could go here
            # For example, checking that qubit_count matches the expected formula
            # Or that circuit depth is reasonable for the number of layers

            return True
        except json.JSONDecodeError:
            print("Invalid JSON in circuit descriptor")
            return False

    def _verify_measurement_results(self, results, expected_qubit_count):
        """
        Verify that the measurement results are consistent with the qubit count.
        """
        # Check that results is a list of 0s and 1s
        if not isinstance(results, list):
            return False

        # Check that each result is a 0 or 1
        for result in results:
            if result not in [0, 1]:
                return False

        # Check that the number of results matches the expected qubit count
        if len(results) != expected_qubit_count:
            return False

        return True


def verify_quantum_challenge_solution(challenge, proof, validator_address):
    """
    Verify a solution to a quantum challenge.

    Args:
        challenge: The original challenge that was issued
        proof: The quantum proof submitted as a solution
        validator_address: Address of the validator submitting the proof

    Returns:
        True if the solution is valid, False otherwise
    """
    # Verify the proof itself
    verifier = QuantumProofVerifier()
    if not verifier.verify_proof(proof):
        return False

    # Check that the proof matches the challenge requirements
    if proof['qubit_count'] < challenge['qubit_count']:
        print("Proof does not meet minimum qubit count requirement")
        return False

    # Check that the proof was generated recently enough
    import time
    current_time = time.time()
    if current_time - proof['timestamp'] > challenge['deadline'] - challenge['timestamp']:
        print("Proof submitted after deadline")
        return False

    # Additional checks could be added here
    # For example, checking that the validator has sufficient stake

    return True


if __name__ == "__main__":
    # Example usage

    print("Testing quantum proof verification...")

    # Generate a quantum proof
    proof = generate_quantum_proof(qubit_count=10, difficulty_level=1)
    print(f"Generated proof with {proof['qubit_count']} qubits")

    # Create a verifier
    verifier = QuantumProofVerifier()

    # Verify the proof
    is_valid = verifier.verify_proof(proof)
    print(f"Proof is valid: {is_valid}")

    # Try to verify the same proof again (should fail due to replay attack prevention)
    is_valid_duplicate = verifier.verify_proof(proof)
    print(f"Duplicate proof is valid: {is_valid_duplicate}")

    # Create an invalid proof by modifying the measurement results
    invalid_proof = proof.copy()
    invalid_proof['measurement_results'][0] = 1 - invalid_proof['measurement_results'][0]  # Flip first bit

    # Verify the invalid proof (should fail)
    is_valid_invalid = verifier.verify_proof(invalid_proof)
    print(f"Invalid proof is valid: {is_valid_invalid}")